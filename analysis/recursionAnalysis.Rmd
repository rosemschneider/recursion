---
title: "RecursionAnalysis"
author: "Rose Schneider"
date: "7/19/2018"
output: html_document
---

```{r setup, include=FALSE}
rm(list = ls())
require("knitr")
opts_knit$set(root.dir = "~/Documents/Projects/recursion/") #this is specific to RMS, change accordingly
library(tidyverse)
library(magrittr)
library(langcog)
library(lme4)
library(stringr)
library(RColorBrewer)
library(ggthemes)
```

```{r functions, include = FALSE}
# copied from stackoverflow
# https://stackoverflow.com/questions/34096162/dplyr-mutate-replace-on-a-subset-of-rows
mutate_cond <- function(.data, condition, ..., envir = parent.frame()) {
  condition <- eval(substitute(condition), .data, envir)
  .data[condition, ] <- .data[condition, ] %>% mutate(...)
  .data
}
```

Loading data
```{r}
full.data <- read.csv('data/recursionData.csv', na.strings=c(""," ","NA"))
```

Reasons for exclusion and their numbers
```{r}
full.data %>%
  filter(ExclusionGroup != "include") %>%
  distinct(LadlabID, .keep_all = TRUE) %>%
  group_by(ExclusionGroup) %>%
  summarize(countN = n_distinct(LadlabID)) %>%
  kable()
```

First, let's remove anyone who should not be included in the final dataset.
```{r}
full.data %<>%
  filter(ExclusionGroup == "include")
```

Number of kids by age group and average age
```{r}
full.data %>%
  group_by(AgeGroup) %>%
  summarize(sumAge = n_distinct(LadlabID)) %>%
  kable()

full.data %>%
  distinct(LadlabID, .keep_all = TRUE) %>%
  summarize(minAge = min(Age),
            maxAge = max(Age),
            meanAge = mean(Age)) %>%
  kable()
```

Number of kids who were classified as prod, nonprod, NA
```{r}
library(naniar)
# discovered a typo
full.data %<>%
  replace_with_na(replace = list(Response = c("NA ", "NA"))) #replacing the typos with NA

full.data %>%
  filter(TaskType == "productivity") %>%
  droplevels()%>%
  distinct(LadlabID, .keep_all = TRUE) %>%
  group_by(Response) %>%
  summarize(sumProd = n_distinct(LadlabID)) %>%
  kable()
```

Prepare data for some highest count graphs
```{r}
hc.data <- full.data %>%
  filter(Task == "HC") %>%
  select(LadlabID, Gender, Age, AgeGroup, HCReceivedSupport, TaskType, TaskItem, Response)

hc.datawide <- hc.data %>% 
  unite(hcItem, TaskType, TaskItem, sep=".") %>% 
  spread(hcItem, Response)

# I did some cleaning to shorten variable names and convert to numeric
# because of how excel datasheet is structued. string and numeric are in one column in full.data
hc.datawide <- hc.datawide %>%
  rename(productivity = productivity.classification) %>%
  rename(spon.consec = spontaneous.consecutive) %>%
  rename(dce = spontaneous.decchangeerror) %>%
  rename(ihc = spontaneous.IHC) %>%
  rename(junyi.ihc = spontaneous.noerror) %>%
  rename(sup.noerror = supported.noerror) %>%
  rename(sup.times = supported.times) %>%
  mutate(spon.consec = as.numeric(levels(spon.consec)[spon.consec])) %>%
  mutate(dce = as.numeric(levels(dce)[dce])) %>%
  mutate(ihc = as.numeric(levels(ihc)[ihc])) %>%
  mutate(junyi.ihc = as.numeric(levels(junyi.ihc)[junyi.ihc])) %>%
  mutate(sup.noerror = as.numeric(levels(sup.noerror)[sup.noerror])) %>%
  mutate(sup.times = as.numeric(levels(sup.times)[sup.times]))

# to make it cleaner, cap ihc > 100 to 100
hc.datawide <- hc.datawide %>%
  mutate_cond(ihc > 100, ihc = 100) #function copied from stackoverflow
```

Overall average on IHC, DCE, and Decade-supported highest count, collapse across kids
```{r}
hc.datawide %>%
  select(LadlabID, Age, productivity, ihc, dce, sup.noerror) %>%
  gather(hcprogression, hc, ihc:sup.noerror) %>%
  mutate(hcprogression = factor(hcprogression, 
                                levels = c("ihc", "dce", "sup.noerror"))) %>%
  group_by(hcprogression) %>%
  summarize(mean = mean(hc, na.rm=TRUE),
            sd = sd(hc, na.rm=TRUE),
            count=n())
```

Same data but by decade productivity group status
```{r}
# same data but by group
hc.datawide %>%
  select(LadlabID, Age, productivity, ihc, dce, sup.noerror) %>%
  gather(hcprogression, hc, ihc:sup.noerror) %>%
  mutate(hcprogression = factor(hcprogression, 
         levels = c("ihc", "dce", "sup.noerror"))) %>%
  group_by(productivity, hcprogression) %>%
  summarize(mean = mean(hc, na.rm=TRUE),
            sd = sd(hc, na.rm=TRUE),
            count=n()) %>%
  kable()
```

Plotting distribution of IHC, as a function of productivity (~ junyi's graph)
```{r}
ggplot(hc.datawide, aes(x=ihc, colour = productivity)) + 
  geom_dotplot(aes(fill = productivity),
    binwidth=1.5, stackgroups=TRUE, binpositions="all",
    brewerPalette="Set2") +
  scale_y_continuous(breaks=seq(0,50,10), lim=c(0,50)) +
  scale_x_continuous(breaks=seq(0,100,by=10)) +
  labs(title="Initial Highest Count",  
       x="IHC (no error)", 
       y="Frequency") +
  theme_bw() + 
  theme(legend.position="bottom")
```

Plotting productivity as a function of age in months (need some fixing)
```{r}
# need some FIXING FOR THIS ONE
# y axis doesn't seem right? change scale_y_continuous to 0,40,10 
# and shape of distribution remains. Wondering whether it's P density
ggplot(hc.datawide, aes(x=Age, colour = productivity)) + 
  geom_dotplot(aes(fill = productivity),
               binwidth = .03,
               stackgroups=TRUE, binpositions="all") +
  scale_y_continuous(breaks=seq(0,20,10), lim=c(0,20)) +
  scale_x_continuous(breaks=seq(4,6,by=.5)) +
  labs(title="Productivity by Age", 
       x="Age in Months", 
       y="Frequency") +
  theme_bw() + 
  theme(legend.position="bottom")
```

Restruture data to plot distance between ihc, dce, and final count
```{r}
hc.dev.data <- hc.datawide %>%
  select(LadlabID, Age, productivity, ihc, dce, sup.noerror) %>%
  gather(hcprogression, hc, ihc:sup.noerror)

hc.dev.data$hcprogression <- 
  factor(hc.dev.data$hcprogression, levels = c("ihc", "dce", "sup.noerror"))

#all kids together
ggplot(hc.dev.data, aes(x = LadlabID, y = hc)) + 
  facet_grid(rows = vars(productivity)) +
  geom_line() + 
  geom_point(aes(shape = hcprogression, colour = hcprogression), 
             size = 2, stroke = 1.5) +
  scale_color_brewer(palette="Dark2") +
  scale_shape_manual(values = c(4,5,20)) +
  labs(title="Highest Count Progression by Decade Productivity",
       x = "Each line = individual kids",
       y="Highest Count by Count Type") +
  theme_bw() + 
  theme(legend.position="bottom", 
        axis.text.x = element_text(angle = 270, hjust = 1))

#for easier viewing, just going to break this up into individual plots
#productive
ggplot(subset(hc.dev.data, productivity == "prod"), aes(x = LadlabID, y = hc)) + 
  facet_grid(rows = vars(productivity)) +
  geom_line() + 
  geom_point(aes(shape = hcprogression, colour = hcprogression), 
             size = 2, stroke = 1.5) +
  scale_color_brewer(palette="Dark2") +
  scale_shape_manual(values = c(4,5,20)) +
  labs(title="Highest Count Progression by Decade Productivity",
       x = "Each line = individual kids",
       y="Highest Count by Count Type") +
  theme_bw() + 
  theme(legend.position="bottom", 
        axis.text.x = element_text(angle = 270, hjust = 1)) + 
  labs(title = "Distance, Productive")

#nonproductive
ggplot(subset(hc.dev.data, productivity == "nonprod"), aes(x = LadlabID, y = hc)) + 
  facet_grid(rows = vars(productivity)) +
  geom_line() + 
  geom_point(aes(shape = hcprogression, colour = hcprogression), 
             size = 2, stroke = 1.5) +
  scale_color_brewer(palette="Dark2") +
  scale_shape_manual(values = c(4,5,20)) +
  labs(title="Highest Count Progression by Decade Productivity",
       x = "Each line = individual kids",
       y="Highest Count by Count Type") +
  theme_bw() + 
  theme(legend.position="bottom", 
        axis.text.x = element_text(angle = 270, hjust = 1)) + 
  labs(title = "Distance, Nonproductive")


#NA kids
ggplot(subset(hc.dev.data, is.na(productivity)), aes(x = LadlabID, y = hc)) + 
  facet_grid(rows = vars(productivity)) +
  geom_line() + 
  geom_point(aes(shape = hcprogression, colour = hcprogression), 
             size = 2, stroke = 1.5) +
  scale_color_brewer(palette="Dark2") +
  scale_shape_manual(values = c(4,5,20)) +
  labs(title="Highest Count Progression by Decade Productivity",
       x = "Each line = individual kids",
       y="Highest Count by Count Type") +
  theme_bw() + 
  theme(legend.position="bottom", 
        axis.text.x = element_text(angle = 270, hjust = 1)) + 
  labs(title = "NA kids")
```

Number of decade prompts provided. M = 3.5 (SD = 1.7), range 1 to 7, N = 31. 40 kids counted to 100 on their own
```{r}
hc.datawide %>%
  filter(productivity == "prod") %>%
  group_by(HCReceivedSupport) %>%
  summarize(mean = mean(sup.times, na.rm=TRUE),
            sd = sd(sup.times, na.rm=TRUE),
            min = min(sup.times, na.rm=TRUE),
            max = max(sup.times, na.rm=TRUE),
            count=n())
# there're 5 kids with blank HCReceivedSupport. why?
# check Excel, seems like these kids spon counted past 100 on their own. coded as NA under HCRecSupport
# some inconsistencies wrt how it's coded. assume 0 = NA
# need to clean this upfront
```

Detective work 1a: For kids without prod status (NA), why do some of them have DCE and sup.noerror? 1a focuses on DCE
```{r}
test1a <- hc.datawide %>%
  filter(is.na(productivity)) %>%
  filter(!is.na(dce))
# 3 kids: PC missed two kids. AL (also coded by RMS) and BH. NEED TO FIX RAW SHEET. UGH
# E error on OM (should've provided prompt but didn't)
```

Detective work 1b: focus on sup.noerror
```{r}
test1b <- hc.datawide %>%
  filter(is.na(productivity)) %>%
  filter(!is.na(sup.noerror))
# results: in most cases, E shouldn't have provided a decade prompt but s/he did, and
# not entirely clear how sup.noerror was coded. error-free in most but not all cases
# thought: ignore sup.noerror for these kids who didn't have DCE?
```

Detective work 2: For those classified as productive, why were IHC < 99 but no DCE?
```{r}
test2 <- hc.datawide %>%
  filter(productivity == "prod") %>%
  filter(ihc < 99 & is.na(dce))
# these kids seem fine. had a lower ihc but made less than 3 errors before reaching final count, which is the criterion we used for those who had DCE. 
# for these kids, their final count can be taken from spon.consec
# because they didn't recieve decade support so nothing under sup.noerror
```

WCH: Children were provided with momentum trials if they got wrong on immediate trials. Check %trials where immediate = wrong, momentum = right


```{r}
wcn.wide <- full.data %>%
  filter(ExclusionGroup == "include") %>%
  filter(Task == "WCN") %>%
  filter(TaskType != "practice") %>%
  filter(TaskItem != 3) %>% # a trial on 3 for momentum that doesn't exist for immediate
  select(LadlabID, Age, AgeGroup, TaskType, TaskItem, Accuracy) %>%
  spread(TaskType, Accuracy)

# data check: there shouldn't be any kids who got 1 for immediate but 0 for momentum or 1 for immediate and 1 for momentum (less of a problem)
##pulling out these kids below
wcn.check <- full.data %>%
  filter(Task == "WCN", 
         TaskType == "momentum" | TaskType == "immediate")%>%
  select(LadlabID, Age, AgeGroup, TaskType, TaskItem, Accuracy) %>%
  spread(TaskType, Accuracy)%>%
  mutate(issue_immediate1Momentum0 = ifelse(immediate == 1 & momentum == 0, TRUE, FALSE), 
         issue_immediate1Momentum1 = ifelse(immediate == 1 & momentum == 1, TRUE, FALSE))%>%
  filter(issue_immediate1Momentum0 == TRUE | 
           issue_immediate1Momentum1 == TRUE)
#7 kids with this issue - exclude??

# how many kids show improved performance
xtabs(~immediate + momentum, data = wcn.wide, na.action = na.pass, exclude = NULL)
# answer: 191 / 1048 trials = ~ 18%
```

Add whether the Task Item was within or outside of the kid's initial highest count. 
```{r}
#first, get initial highest count for each kiddo
#Make a lookup table with SID and initial highest count
lookup <- full.data %>%
  filter(TaskItem == "IHC")%>%
  droplevels()%>%
  distinct(LadlabID, Response)

wcn.wide %<>%
  mutate(TaskItem = as.numeric(as.character(TaskItem)))

#This is a function that, for each trial, checks the number queried. If number queried is above the child's initial highest count, marks that trial as beyond count range.
determine_count_range <- function(df) {
  tmp <- df
  for (row in 1:nrow(tmp)) {
    sub = as.character(tmp[row, "LadlabID"])
    count_range = as.numeric(as.character(subset(lookup, LadlabID == sub)$Response))
    tmp[row, "IHC"] = as.numeric(as.character(count_range))
    if (tmp[row, "TaskItem"] > count_range) {
      tmp[row, "WithinOutsideIHC"] = "outside"
    } else {
      tmp[row, "WithinOutsideIHC"] = "within"
    }
  }
  return(tmp)
}

#Run for wcn
wcn.wide <- determine_count_range(wcn.wide)
```

Percent Correct on WCH
```{r}
wcn.average <- wcn.wide %>%
  group_by(LadlabID) %>%
  summarize(avg.wcn = mean(immediate, na.rm=TRUE),
            sd.wch = sd(immediate, na.rm=TRUE))

hc.datawide <- left_join(wcn.average, hc.datawide)

hc.datawide %>%
  group_by(productivity) %>%
  summarize(mean = mean(avg.wcn))
```
WCN accuracy, within and outside of IHC
```{r}
wcn.wide %>%
  group_by(WithinOutsideIHC) %>%
  summarize(mean = mean(immediate, na.rm = TRUE), 
            sd = sd(immediate, na.rm = TRUE), 
            median = median(immediate, na.rm = TRUE))
```
     

Now divide the data up into separate data frames for each task for ease of analysis within each one.
```{r}
hc.data <- full.data %>%
  filter(Task == "HC")

wcn.data <- full.data %>%
  filter(Task == "WCN")

infinity.data <- full.data %>%
  filter(Task != "HC", 
         Task != "WCN")
```

Checking to make sure that everything is correctly coded for WCN
```{r}
wcn.data %<>%
  mutate(Response_num = as.numeric(as.character(Response)), 
         TaskItem_num = as.numeric(as.character(TaskItem)), 
         Accuracy_check = ifelse(Response_num == (TaskItem_num + 1), 1, 0), 
         Accuracy_valid = ifelse(Accuracy == Accuracy_check, TRUE, FALSE))

validate <- function(){
  validation <- wcn.data %>%
  filter(Accuracy_valid == FALSE)
  if(length(validation$LadlabID) > 0) {
    print("WARNING: CHECK CODING")
  } else {
    print("All coding correct")
  }
}

validate()
```

```{r}
wcn.test <- wcn.data %>%
  mutate(Response_num = as.numeric(as.character(Response)), 
         TaskItem_num = as.numeric(as.character(TaskItem)), 
         Response_check = ifelse(Response == Response_num, TRUE, FALSE), 
         TaskItem_check = ifelse(TaskItem == TaskItem_num, TRUE, FALSE))%>%
  filter(Response_check == FALSE | TaskItem_check == FALSE)
```






#Analyses
##1: Counting, Productivity, and Infinity Battery (Successor)
To identify whether there is connection between counting experience and Successor Task performance, we will conduct three initial analyses, predicting Successor Task performance from either (1) Initial Highest Count, (2) Productivity for Decade Rule (defined above), or (3) performance on the Next Number task. 

glmer(infsucc_correct ~ (predictor) + age + (1|subject), family = binomial).

Simple Models
Model 1: Successor.Infinity ~ Initial.Count + Age + (1|subject)
Model 2: Successor.Infinity ~ Productivity.Decade + Age + (1|subject)
Model 3: Successor.Infinity ~ Highest.Next.Number  + Age + (1|subject)

---
First, we need to make a model data frame that readily has all of this information

Initial Count
```{r}
#model base
model.df <- full.data %>%
  select(LadlabID, Age, AgeGroup, Gender, Task, Response, SuccessorKnower, EndlessKnower)

#create a lookup
lookup <- full.data %>%
  filter(TaskItem == "IHC")%>%
  distinct(LadlabID, Response)

#spread to model df 
add_ihc <- function(){
  subjects <- as.vector(lookup$LadlabID)
  tmp <- model.df 
  for (row in 1:nrow(tmp)){
    current_sub = as.character(tmp[row, "LadlabID"])
    ihc = subset(lookup, LadlabID == current_sub)$Response
    tmp[row, "IHC"] = ihc
  }
  return(tmp)
}

#change this later to model df
model.df <- add_ihc()
```

Highest Next Number
```{r}
lookup <- full.data %>%
  filter(Task == "WCN", 
         Accuracy == 1)%>%
  group_by(LadlabID)%>%
  summarise(max = max(as.numeric(as.character(TaskItem)))) 

# Descriptives on WCN max
hc.datawide <- left_join(lookup, hc.datawide)

hc.datawide %>%
  select(LadlabID, Age, AgeGroup, productivity, max, 
    HCReceivedSupport, ihc, dce, sup.noerror) %>%
  group_by(productivity) %>%
  summarize(median = median(max, na.rm=TRUE),
            count = n())
#median is 86 for all groups

#Add highest NN to model df
add_highest_num <- function() {
  tmp <- model.df
  for (row in 1:nrow(tmp)) {
    sub = as.character(tmp[row, "LadlabID"])
    highest_num = subset(lookup, LadlabID == sub)$max
    tmp[row, "Highest_NN"] = highest_num
  }
  return(tmp)
}

#run this function on model df
model.df <- add_highest_num()
```

Productivity classification
TO-DO for RMS: Only some kids will have productivity classifications, so this will need to be a separate dataset
```{r}
lookup <- full.data %>%
  filter(TaskType == "productivity")%>%
  distinct(LadlabID, Response)

add_productivity <- function() {
  tmp <- model.df
  for (row in 1:nrow(tmp)) {
    sub = as.character(tmp[row, "LadlabID"])
    productivity = subset(lookup, LadlabID == sub)$Response
    tmp[row, "Prod_Class"] = productivity
  }
  return(tmp)
}

z <- add_productivity()

```


```{r}
#each participant only needs one row here
distinct_model.df <- model.df %>%
  distinct(LadlabID, Age, AgeGroup, Gender, SuccessorKnower, EndlessKnower, 
           IHC, Highest_NN)%>%
  mutate(SuccessorKnower = factor(SuccessorKnower, levels = c(0,1)), 
         EndlessKnower = factor(EndlessKnower, levels = c(0,1)), 
         IHC = as.numeric(as.character(IHC)))

#base model
base.model <- glmer(SuccessorKnower ~ Age + (1|LadlabID), family = "binomial", 
                    data = distinct_model.df)
#IHC
model1.sf <- glmer(SuccessorKnower ~ IHC + Age + (1|LadlabID), family = "binomial", 
                   data = distinct_model.df)
#convergence warnings, is this an issue?
with(model1.sf@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)

#compare
anova(base.model, model1.sf, test = 'LRT') #IHC not significant

#highest nn
model2.sf <- glmer(SuccessorKnower ~ Highest_NN + Age + (1|LadlabID), family = "binomial", 
                   data = distinct_model.df)
#convergence warnings, is this an issue?
with(model2.sf@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)

#compare
anova(base.model, model2.sf, test = 'LRT')#highest NN not significant

#TO-DO for RMS: Need to do productivity
```

Endless Knower
```{r}
base.endless <- glmer(EndlessKnower ~ Age + (1|LadlabID), family = "binomial", 
                      data = distinct_model.df)
model1.endless <- glmer(EndlessKnower ~ IHC + Age + (1|LadlabID), family = "binomial", 
                        data = distinct_model.df)
#convergence warnings, is this an issue?
with(model1.endless@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)

#compare
anova(base.endless, model1.endless, test = 'LRT') #IHC significant

model2.endless <- glmer(EndlessKnower ~ Highest_NN + Age + (1|LadlabID), family = "binomial", 
                        data = distinct_model.df, control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5))) #this is failing to converge, change optimizer, but check
#convergence warnings, is this an issue?
with(model2.endless@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#False, yes, model is failing to converge...
```