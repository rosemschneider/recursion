---
title: "RecursionAnalysis"
author: "Pierina Cheung, Rose M. Schneider, Junyi Chu"
date: "7/19/2018"
output: 
  html_document:
    toc: yes
    toc_float: yes
---

# Setup
```{r setup, include=FALSE}
rm(list = ls())
require("knitr")
# opts_knit$set(root.dir = "~/Documents/Projects/recursion/") #this is specific to RMS, change accordinglyz
opts_knit$set(root.dir = "~/Sites/jchu.github.io/recursion/")
library(tidyverse)
library(magrittr)
library(langcog)
library(lme4)
library(stringr)
library(RColorBrewer)
library(ggthemes)
```

```{r functions, include = FALSE}
# copied from stackoverflow
# https://stackoverflow.com/questions/34096162/dplyr-mutate-replace-on-a-subset-of-rows
mutate_cond <- function(.data, condition, ..., envir = parent.frame()) {
  condition <- eval(substitute(condition), .data, envir)
  .data[condition, ] <- .data[condition, ] %>% mutate(...)
  .data
}
```

## Loading data
```{r}
#original data
full.data <- read.csv('data/recursion_full.csv', na.strings=c(""," ","NA"))
```

Reasons for exclusion and their numbers
```{r}
full.data %>%
  dplyr::filter(ExclusionGroup != "include") %>%
  dplyr::distinct(LadlabID, .keep_all = TRUE) %>%
  dplyr::group_by(ExclusionGroup) %>%
  dplyr::summarize(countN = dplyr::n_distinct(LadlabID)) %>%
  kable()
```

First, let's remove anyone who should not be included in the final dataset.
```{r}
full.data %<>%
  dplyr::filter(ExclusionGroup == "include")
```

Now, add in the Productivity classification, IHC, and FHC from PC, JC, and RMS coding

<span style="color:red">Question from RMS: is FHC capped at 100 as well?</span>

```{r}
#productivity, fhc, ihc coding from pc, jc, and rms
hc.data <- read.csv('data/HC-datawide-forcoding - hc.datawide.csv') %>%
  dplyr::select(LadlabID, prod_tomerge, ihc_tomerge, fhc_tomerge, dce)

full.data <- dplyr::right_join(full.data, hc.data, by = "LadlabID")

full.data %<>%
  dplyr::rename(Productivity = prod_tomerge, 
                IHC = ihc_tomerge, 
                FHC = fhc_tomerge, 
                DCE = dce)%>%
  dplyr::mutate(Productivity = factor(Productivity, levels = c("nonprod", "prod"), 
                               labels = c("Nonproductive", "Productive")), 
         IHC = ifelse(IHC > 100, 100, IHC))
```

Number of kids by age group and average age
```{r}
full.data %>%
  dplyr::group_by(AgeGroup) %>%
  dplyr::summarize(sumAge = n_distinct(LadlabID)) %>%
  kable()

full.data %>%
  dplyr::distinct(LadlabID, .keep_all = TRUE) %>%
  dplyr::summarize(minAge = min(Age),
            maxAge = max(Age),
            meanAge = mean(Age)) %>%
  kable()
```

Number of kids who were classified as prod, nonprod, NA
```{r}
full.data %>%
  dplyr::distinct(LadlabID, Productivity)%>%
  dplyr::group_by(Productivity)%>%
  dplyr::summarise(n = n())
```

Just for reference, this is the number of kids who switched classifications from PC, JC, RMS recode
```{r}
library(naniar)
# discovered a typo
full.data %<>%
  replace_with_na(replace = list(Response = c("NA ", "NA"))) #replacing the typos with NA

full.data %>%
  dplyr::filter(TaskType == "productivity") %>%
  droplevels()%>%
  dplyr::distinct(LadlabID, Response, Productivity) %>%
  dplyr::mutate(Response = factor(Response, levels = c("nonprod", "prod"), 
                           labels = c("Nonproductive", "Productive")))%>%
  dplyr::mutate(changed_classification = ifelse((is.na(Response) & Productivity == "Nonproductive"),
                                         "NA_toNonprod",
                                         ifelse((is.na(Response) & Productivity == "Productive"), 
                                                "NA_toProd", 
                                                ifelse((Response == "Nonproductive" & Productivity == "Productive"), 
                                                       "Nonprod_toProd", 
                                                       ifelse((Response == "Productive" & Productivity == "Nonproductive"),
                                                              "Prod_toNonprod", "no_change")))))%>%
  dplyr::group_by(changed_classification)%>%
  dplyr::summarise(n =n())

```

***
# Highest count data

Prepare data for some highest count graphs
```{r}
# hc.data <- full.data %>%
#   filter(Task == "HC") %>%
#   dplyr::select(LadlabID, Gender, Age, AgeGroup, HCReceivedSupport, TaskType, TaskItem, Response, Productivity, FHC, IHC, DCE)
# 
# hc.datawide <- hc.data %>% 
#   unite(hcItem, TaskType, TaskItem, sep=".") %>% 
#   spread(hcItem, Response)
# 
# # I did some cleaning to shorten variable names and convert to numeric
# # because of how excel datasheet is structued. string and numeric are in one column in full.data
# hc.datawide <- hc.datawide %>%
#   rename(productivity = productivity.classification) %>%
#   rename(spon.consec = spontaneous.consecutive) %>%
#   rename(dce = spontaneous.decchangeerror) %>%
#   rename(ihc = spontaneous.IHC) %>%
#   rename(junyi.ihc = spontaneous.noerror) %>%
#   rename(sup.noerror = supported.noerror) %>%
#   rename(sup.times = supported.times) %>%
#   mutate(spon.consec = as.numeric(levels(spon.consec)[spon.consec])) %>%
#   mutate(dce = as.numeric(levels(dce)[dce])) %>%
#   mutate(ihc = as.numeric(levels(ihc)[ihc])) %>%
#   mutate(junyi.ihc = as.numeric(levels(junyi.ihc)[junyi.ihc])) %>%
#   mutate(sup.noerror = as.numeric(levels(sup.noerror)[sup.noerror])) %>%
#   mutate(sup.times = as.numeric(levels(sup.times)[sup.times]))
# 
# # to make it cleaner, cap ihc > 100 to 100
# hc.datawide <- hc.datawide %>%
#   mutate_cond(ihc > 100, ihc = 100) #function copied from stackoverflow
```

Overall average on IHC, DCE, and Decade-supported highest count, collapse across kids
```{r}
# hc.datawide %>%
#   dplyr::select(LadlabID, Age, productivity, ihc, dce, sup.noerror) %>%
#   gather(hcprogression, hc, ihc:sup.noerror) %>%
#   mutate(hcprogression = factor(hcprogression, 
#                                 levels = c("ihc", "dce", "sup.noerror"))) %>%
#   group_by(hcprogression) %>%
#   summarize(mean = mean(hc, na.rm=TRUE),
#             sd = sd(hc, na.rm=TRUE),
#             count=n())
```

Same data but by decade productivity group status
```{r}
# # same data but by group
# hc.datawide %>%
#   dplyr::select(LadlabID, Age, productivity, ihc, dce, sup.noerror) %>%
#   gather(hcprogression, hc, ihc:sup.noerror) %>%
#   mutate(hcprogression = factor(hcprogression, 
#          levels = c("ihc", "dce", "sup.noerror"))) %>%
#   group_by(productivity, hcprogression) %>%
#   summarize(mean = mean(hc, na.rm=TRUE),
#             sd = sd(hc, na.rm=TRUE),
#             count=n()) %>%
#   kable()
```

Average of IHC, DCE, and FHC for all kids
```{r}
full.data %>%
  dplyr::distinct(LadlabID, IHC, FHC, DCE)%>%
  dplyr::summarise(mean_IHC = mean(IHC),
            sd_IHC = sd(IHC),
            mean_FHC = mean(FHC),
            sd_FHC = sd(FHC), 
            mean_DCE = mean(DCE, na.rm = TRUE), 
            sd_DCE = sd(DCE, na.rm = TRUE))
```

Same data by productivity
```{r}
full.data %>%
  dplyr::distinct(LadlabID, Productivity, FHC, IHC, DCE)%>%
  dplyr::group_by(Productivity)%>%
  dplyr::summarise(mean_IHC = mean(IHC),
            sd_IHC = sd(IHC),
            mean_FHC = mean(FHC),
            sd_FHC = sd(FHC), 
            mean_DCE = mean(DCE, na.rm = TRUE), 
            sd_DCE = sd(DCE, na.rm = TRUE))
```

Plotting distribution of IHC, as a function of productivity (~ junyi's graph)

<span style="color:red">Note from RMS: This doesn't look right based on a histogram of the IHC data, but I'm moving onto analyses with a flag to fix this later, because I'm not quite sure what's going wrong - looks like there might be weirdness translating between count (proportion) and frequency??</span>
<span style="color:blue">Note from JC: Fix by changing binwidth=1 (from 1.5) and adding coord_fixed(ratio=1) so that 1 dot is 1 on the y-axis.</span>

```{r}
unique.hc.data <- full.data %>%
  dplyr::distinct(LadlabID, Gender, Age, AgeGroup, HCReceivedSupport, IHC, DCE, FHC, Productivity)

ggplot(unique.hc.data, aes(x=IHC, color=Productivity)) + 
  geom_dotplot(aes(fill = Productivity),
    binwidth=1, stackgroups=TRUE, binpositions="all",method="dotdensity") +
  scale_color_brewer(palette="Set2") + 
  scale_fill_brewer(palette="Set2") +
  coord_fixed(ratio=1) +
  scale_y_continuous(breaks=seq(0,40,10), lim=c(0,35)) +
  scale_x_continuous(breaks=seq(0,100,by=10)) +
  labs(title="Initial Highest Count",  
       x="IHC (no error)", 
       y="Frequency") +
  theme_bw() + 
  theme(legend.position="bottom")

hist(unique.hc.data$IHC)
```

Plotting productivity as a function of age in months (need some fixing)

<span style="color:red">Note from RMS: make sure this doesn't have the same issue as above</span>
<span style="color:blue">Note from JC: Added AgeMonths variable, added coord_fixed etc. just like previous graph. </span>
```{r}
# need some FIXING FOR THIS ONE
# y axis doesn't seem right? change scale_y_continuous to 0,40,10 
# and shape of distribution remains. Wondering whether it's P density
unique.hc.data$AgeMonths = floor(unique.hc.data$Age*12)

ggplot(unique.hc.data, aes(x=AgeMonths, colour = Productivity)) + 
  geom_dotplot(aes(fill = Productivity),
               binwidth = 1,
               stackgroups=TRUE, binpositions="all") +
  coord_fixed(ratio=1) +
  scale_y_continuous(breaks=seq(0,10,5), lim=c(0,12)) +
  scale_x_continuous(breaks=seq(48,72,by=6)) +
  scale_color_brewer(palette="Set2") + 
  scale_fill_brewer(palette="Set2") +
  labs(title="Productivity by Age", 
       x="Age in Months", 
       y="Frequency") +
  theme_bw() + 
  theme(legend.position="bottom")
```

## Distance between IHC and FHC

Restruture data to plot distance between ihc, dce, and final count
```{r}
hc.dev.data <- full.data %>%
  dplyr::select(LadlabID, Age, Productivity, IHC, DCE, FHC) %>%
  gather(hcprogression, hc, IHC:FHC)%>%
  mutate(hcprogression = factor(hcprogression, levels = c("IHC", "DCE", "FHC")))

#all kids together
ggplot(hc.dev.data, aes(x = LadlabID, y = hc)) + 
  facet_grid(rows = vars(Productivity)) +
  geom_line() + 
  geom_point(aes(shape = hcprogression, colour = hcprogression), 
             size = 2, stroke = 1.5) +
  scale_color_brewer(palette="Dark2") +
  scale_shape_manual(values = c(4,5,20)) +
  labs(title="Highest Count Progression by Decade Productivity",
       x = "Each line = individual kids",
       y="Highest Count by Count Type") +
  theme_bw() + 
  theme(legend.position="bottom", 
        axis.text.x = element_text(angle = 270, hjust = 1))

#for easier viewing, just going to break this up into individual plots
#productive
ggplot(subset(hc.dev.data, Productivity == "Productive"), aes(x = LadlabID, y = hc)) + 
  facet_grid(rows = vars(Productivity)) +
  geom_line() + 
  geom_point(aes(shape = hcprogression, colour = hcprogression), 
             size = 2, stroke = 1.5) +
  scale_color_brewer(palette="Dark2") +
  scale_shape_manual(values = c(4,5,20)) +
  labs(title="Highest Count Progression by Decade Productivity",
       x = "Each line = individual kids",
       y="Highest Count by Count Type") +
  theme_bw() + 
  theme(legend.position="bottom", 
        axis.text.x = element_text(angle = 270, hjust = 1)) + 
  labs(title = "Distance, Productive")

#nonproductive
ggplot(subset(hc.dev.data, Productivity == "Nonproductive"), aes(x = LadlabID, y = hc)) + 
  facet_grid(rows = vars(Productivity)) +
  geom_line() + 
  geom_point(aes(shape = hcprogression, colour = hcprogression), 
             size = 2, stroke = 1.5) +
  scale_color_brewer(palette="Dark2") +
  scale_shape_manual(values = c(4,5,20)) +
  labs(title="Highest Count Progression by Decade Productivity",
       x = "Each line = individual kids",
       y="Highest Count by Count Type") +
  theme_bw() + 
  theme(legend.position="bottom", 
        axis.text.x = element_text(angle = 270, hjust = 1)) + 
  labs(title = "Distance, Nonproductive")
```

Number of decade prompts provided. M = 3.5 (SD = 1.7), range 1 to 7, N = 31. 40 kids counted to 100 on their own

<span style="color:red">Note from RMS: I haven't fixed this yet</span>
```{r}
# full.data %>%
#   filter(Productivity == "Productive") %>%
#   group_by(HCReceivedSupport) %>%
#   summarize(mean = mean(sup.times, na.rm=TRUE),
#             sd = sd(sup.times, na.rm=TRUE),
#             min = min(sup.times, na.rm=TRUE),
#             max = max(sup.times, na.rm=TRUE),
#             count=n())
# there're 5 kids with blank HCReceivedSupport. why?
# check Excel, seems like these kids spon counted past 100 on their own. coded as NA under HCRecSupport
# some inconsistencies wrt how it's coded. assume 0 = NA
# need to clean this upfront
```

### PC detective work

Detective work 1a: For kids without prod status (NA), why do some of them have DCE and sup.noerror? 1a focuses on DCE
```{r}
# test1a <- hc.datawide %>%
#   filter(is.na(productivity)) %>%
#   filter(!is.na(dce))
# 3 kids: PC missed two kids. AL (also coded by RMS) and BH. NEED TO FIX RAW SHEET. UGH
# E error on OM (should've provided prompt but didn't)
```

Detective work 1b: focus on sup.noerror
```{r}
# test1b <- hc.datawide %>%
#   filter(is.na(productivity)) %>%
#   filter(!is.na(sup.noerror))
# results: in most cases, E shouldn't have provided a decade prompt but s/he did, and
# not entirely clear how sup.noerror was coded. error-free in most but not all cases
# thought: ignore sup.noerror for these kids who didn't have DCE?
```

Detective work 2: For those classified as productive, why were IHC < 99 but no DCE?
```{r}
# test2 <- hc.datawide %>%
#   filter(productivity == "prod") %>%
#   filter(ihc < 99 & is.na(dce))
# these kids seem fine. had a lower ihc but made less than 3 errors before reaching final count, which is the criterion we used for those who had DCE. 
# for these kids, their final count can be taken from spon.consec
# because they didn't recieve decade support so nothing under sup.noerror
```

# What comes next

WCN: Children were provided with momentum trials if they got wrong on immediate trials. Check %trials where immediate = wrong, momentum = right
```{r}
wcn.wide <- full.data %>%
  filter(ExclusionGroup == "include") %>%
  filter(Task == "WCN") %>%
  filter(TaskType != "practice") %>%
  filter(TaskItem != 3) %>% # a trial on 3 for momentum that doesn't exist for immediate
  droplevels()%>%
  dplyr::select(LadlabID, Age, AgeGroup, TaskType, TaskItem, Accuracy) %>%
  spread(TaskType, Accuracy)

# data check: there shouldn't be any kids who got 1 for immediate but 0 for momentum or 1 for immediate and 1 for momentum (less of a problem)
##pulling out these kids below
wcn.check <- full.data %>%
  filter(Task == "WCN", 
         TaskType == "momentum" | TaskType == "immediate")%>%
  dplyr::select(LadlabID, Age, AgeGroup, TaskType, TaskItem, Accuracy) %>%
  spread(TaskType, Accuracy)%>%
  mutate(issue_immediate1Momentum0 = ifelse(immediate == 1 & momentum == 0, TRUE, FALSE), 
         issue_immediate1Momentum1 = ifelse(immediate == 1 & momentum == 1, TRUE, FALSE))%>%
  filter(issue_immediate1Momentum0 == TRUE | 
           issue_immediate1Momentum1 == TRUE)
#7 kids with this issue - exclude??

# how many kids show improved performance
xtabs(~immediate + momentum, data = wcn.wide, na.action = na.pass, exclude = NULL)
# answer: 191 / 1048 trials = ~ 18%
```

Add whether the Task Item was within or outside of the kid's initial highest count.
```{r}
#first, get initial highest count for each kiddo
#Make a lookup table with SID and initial highest count
lookup <- full.data %>%
  distinct(LadlabID, IHC)

wcn.wide %<>%
  mutate(TaskItem = as.numeric(as.character(TaskItem)))

#This is a function that, for each trial, checks the number queried. If number queried is above the child's initial highest count, marks that trial as beyond count range.
determine_count_range <- function(df) {
  tmp <- df
  for (row in 1:nrow(tmp)) {
    sub = as.character(tmp[row, "LadlabID"])
    count_range = as.numeric(as.character(subset(lookup, LadlabID == sub)$IHC))
    tmp[row, "IHC"] = as.numeric(as.character(count_range))
    if (tmp[row, "TaskItem"] > count_range) {
      tmp[row, "WithinOutsideIHC"] = "outside"
    } else {
      tmp[row, "WithinOutsideIHC"] = "within"
    }
  }
  return(tmp)
}

#Run for wcn
wcn.wide <- determine_count_range(wcn.wide)
```

Highest contiguous NN

<span style="color:red">Note from RMS: There are a few kids that did not pass 1 or both of the practice trials for WCN. Are they to be included?</span>
```{r, warning = FALSE}
unique.nn <- as.vector(unique(wcn.wide$LadlabID))
#get the task items from wcn
nextnums <- as.vector(unique(wcn.wide$TaskItem))

##Okay so it looks like there are 16 participants who did not pass both practice trials for WCN. I may need to hardcode their Highest contiguous, but to be continued
x <- full.data %>%
  filter(Task == "WCN" &
           (TaskItem == 1 | TaskItem == 5))%>%
  group_by(LadlabID)%>%
  summarise(sum = sum(Accuracy))%>%
  filter(sum != 2)

#just hardcoding kids because it's easier than going back to the full data frame
#These kids got 1 right, 5 wrong: 
one.corr <- as.vector(c("012316-BO", "022616-JM", "030216-ED", 
              "030817-ZI", "031516-A", "032216-JH", 
              "032216-RC", "040317-AL", "040317-SL", 
              "041316-AR", "041316-NC", "041316-VN", 
              "062416-MC"))

five.corr <- as.vector("050617-Z1")

zero.corr <- as.vector(c("030216-AD", "040616-K"))
#this is a function that pulls out the largest number for which a participant had a correct consecutive
get_contiguous <- function(){
  contig <- data.frame()
  for (sub in unique.nn) {
    tmp <- wcn.wide %>%
      dplyr::select(LadlabID, Age, AgeGroup, TaskItem, immediate)%>%
      filter(LadlabID == sub, 
             immediate == 0)%>%
      mutate(TaskItem = sort(TaskItem))
    if (length(tmp$LadlabID) == 0) {
      highest_contig = 86
      sub_contig <- data.frame(sub, highest_contig)
      contig <- bind_rows(contig, sub_contig)
    } else if (length(tmp$TaskItem) > 0 & min(tmp$TaskItem) == 23) {
      if(sub %in% one.corr){
        highest_contig = 1
        sub_contig <- data.frame(sub, highest_contig)
        contig <- bind_rows(contig, sub_contig)
      } else if(sub %in% five.corr | sub %in% zero.corr){
        highest_contig = 0
        sub_contig <- data.frame(sub, highest_contig)
        contig <- bind_rows(contig, sub_contig)
      } else {
        highest_contig = 5
        sub_contig <- data.frame(sub, highest_contig)
        contig <- bind_rows(contig, sub_contig)
      }
    } else {
      min.nn <- min(tmp$TaskItem)
      prev_correct <- nextnums[nextnums < min.nn]
      highest_contig <- max(prev_correct)
    
      sub_contig <- data.frame(sub,
                             highest_contig)
      contig <- bind_rows(contig, sub_contig)
    }
  }
  return(contig)
}

highest_contiguous_nn <- get_contiguous()%>%
  dplyr::rename(LadlabID = sub)%>%
  distinct(LadlabID, highest_contig)%>%
  rename(Highest_Contig_NN = highest_contig)

```

Percent Correct on WCN
```{r}
wcn.average <- wcn.wide %>%
  group_by(LadlabID) %>%
  summarize(avg.wcn = mean(immediate, na.rm=TRUE),
            sd.wcn = sd(immediate, na.rm=TRUE))

hc.datawide <- right_join(full.data, wcn.average, by = "LadlabID")

hc.datawide %>%
  group_by(Productivity) %>%
  summarize(mean = mean(avg.wcn))
```

WCN accuracy, within and outside of IHC
```{r}
wcn.wide %>%
  group_by(WithinOutsideIHC) %>%
  summarize(mean = mean(immediate, na.rm = TRUE), 
            sd = sd(immediate, na.rm = TRUE))
```
     
Now WCN by within/outside count range and productivity
```{r}
tmp <- full.data%>%
  distinct(LadlabID, Productivity)%>%
  select(LadlabID, Productivity)

wcn.wide <- right_join(wcn.wide, tmp, by = "LadlabID")

wcn.wide %>%
  group_by(WithinOutsideIHC, Productivity) %>%
  summarize(mean = mean(immediate, na.rm = TRUE), 
            sd = sd(immediate, na.rm = TRUE))
```

How many trials do kids have beyond their IHC?
```{r}
wcn.wide %>%
 dplyr:: select(-momentum)%>%
  group_by(Productivity, WithinOutsideIHC)%>%
  summarise(n = n())
```


Checking to make sure that everything is correctly coded for WCN
```{r}
wcn.data <- full.data %>%
   filter(Task == "WCN")

wcn.data %<>%
  mutate(Response_num = as.numeric(as.character(Response)), 
         TaskItem_num = as.numeric(as.character(TaskItem)), 
         Accuracy_check = ifelse(Response_num == (TaskItem_num + 1), 1, 0), 
         Accuracy_valid = ifelse(Accuracy == Accuracy_check, TRUE, FALSE))

validate <- function(){
  validation <- wcn.data %>%
  filter(Accuracy_valid == FALSE)
  if(length(validation$LadlabID) > 0) {
    print("WARNING: CHECK CODING")
  } else {
    print("All coding correct")
  }
}

validate()
```

```{r}
wcn.test <- wcn.data %>%
  mutate(Response_num = as.numeric(as.character(Response)), 
         TaskItem_num = as.numeric(as.character(TaskItem)), 
         Response_check = ifelse(Response == Response_num, TRUE, FALSE), 
         TaskItem_check = ifelse(TaskItem == TaskItem_num, TRUE, FALSE))%>%
  filter(Response_check == FALSE | TaskItem_check == FALSE)
```






# Analyses
## 1: Counting, Productivity, and Infinity Battery
To identify whether there is connection between counting experience and Successor Task performance, we will conduct three initial analyses, predicting Successor Task performance from either (1) Initial Highest Count, (2) Productivity for Decade Rule (defined above), or (3) performance on the Next Number task. 

glmer(inf.0/1 ~ (predictor) + age + (1|subject), family = binomial).

---
First, we need to make a model data frame that readily has all of this information

```{r}
#model base
model.df <- full.data %>%
  dplyr::select(LadlabID, Age, AgeGroup, Gender, Task, Response, SuccessorKnower, EndlessKnower, 
                IHC, FHC, DCE, Productivity)
```

Highest Next Number - commented because we're using highest contiguous
```{r}
# lookup <- full.data %>%
#   filter(Task == "WCN", 
#          Accuracy == 1)%>%
#   group_by(LadlabID)%>%
#   summarise(max = max(as.numeric(as.character(TaskItem)))) 
# 
# 
# #Add highest NN to model df
# add_highest_num <- function() {
#   tmp <- model.df
#   for (row in 1:nrow(tmp)) {
#     sub = as.character(tmp[row, "LadlabID"])
#     highest_num = subset(lookup, LadlabID == sub)$max
#     tmp[row, "Highest_NN"] = highest_num
#   }
#   return(tmp)
# }
# 
# #run this function on model df
# model.df <- add_highest_num()
```

Add highest contiguous next number to model.df 
```{r}
model.df <- right_join(model.df, highest_contiguous_nn, by = "LadlabID")

# hc.datawide <- right_join(hc.datawide, highest_contiguous_nn, by = "LadlabID")

# hc.datawide %>%
#   dplyr::select(LadlabID, Age, AgeGroup, productivity, max, 
#     HCReceivedSupport, ihc, dce, sup.noerror) %>%
#   group_by(productivity) %>%
#   summarize(median = median(max, na.rm=TRUE),
#             count = n())
# #median is 86 for all groups
```

Get mean WCN for everyone <span style="color:red">Not using this anymore - RMS</span>
```{r}
# lookup <- wcn.wide %>%
#   group_by(LadlabID)%>%
#   summarise(mean.NN = mean(immediate, na.rm = TRUE))
```

## Successor models
```{r}
#each participant only needs one row here, because we only need to know where they are a Successor Knower or Endless Knower
distinct_model.df <- model.df %>%
  distinct(LadlabID, Age, AgeGroup, Gender, SuccessorKnower, EndlessKnower, 
           IHC, Highest_Contig_NN, FHC, DCE, Productivity)%>%
  mutate(SuccessorKnower = factor(SuccessorKnower, levels = c(0,1)), 
         EndlessKnower = factor(EndlessKnower, levels = c(0,1)))%>%
  mutate(IHC = as.integer(IHC), 
         Highest_Contig_NN = as.integer(Highest_Contig_NN), 
         LadlabID = factor(LadlabID))

# #add mean_nn to model df
# distinct_model.df <- right_join(distinct_model.df, lookup, by = "LadlabID")


###MODEL BUILDING AND COMPARISONS###
#base model for successor knower
base.model <- glmer(SuccessorKnower ~ Age + (1|LadlabID), family = "binomial", 
                    data = distinct_model.df)
##IHC model##
model.ihc.sf <- glmer(SuccessorKnower ~ IHC + Age + (1|LadlabID), family = "binomial", 
                   data = distinct_model.df)
#convergence warnings, is this an issue?
with(model.ihc.sf@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#True, so we're okay

#compare
anova(base.model, model.ihc.sf, test = 'LRT') #IHC not significant

##Highest NN Model##
model.nn.sf <- glmer(SuccessorKnower ~ Highest_Contig_NN + Age + (1|LadlabID), family = "binomial", 
                   data = distinct_model.df)

#compare
anova(base.model, model.nn.sf, test = 'LRT')#highest contiguous NN not significant

##Productivity model##
model.prod.sf <- glmer(SuccessorKnower ~ Productivity + Age + (1|LadlabID), family = "binomial", 
                   data = distinct_model.df)

#compare
anova(base.model, model.prod.sf, test = 'LRT')#Productivity trending
```


## Endless Models
```{r}
base.endless <- glmer(EndlessKnower ~ Age + (1|LadlabID), family = "binomial", 
                      data = distinct_model.df)

###IHC MODEL###
model.ihc.endless <- glmer(EndlessKnower ~ IHC + Age + (1|LadlabID), family = "binomial", 
                        data = distinct_model.df)
#convergence warnings, is this an issue?
with(model.ihc.endless@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#true, so we're okay

#compare
anova(base.endless, model.ihc.endless, test = 'LRT') #IHC significant


###HIGHEST CONTIG NN MODEL###
model.nn.endless <- glmer(EndlessKnower ~ Highest_Contig_NN + Age + (1|LadlabID), family = "binomial", 
                        data = distinct_model.df) 
#convergence warnings, is this an issue?
with(model.nn.endless@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#True, model converging

anova(model.nn.endless, base.endless, test = 'LRT')#Highest contig NN significant

###PRODUCTIVITY MODEL###
model.prod.endless <- glmer(EndlessKnower ~ Productivity + Age + (1|LadlabID), family = "binomial", 
                            data = distinct_model.df)

#compare
anova(model.prod.endless, base.endless, test = 'LRT')#Prod significant

# #okay with about mean NN
# model2.endless <- glmer(EndlessKnower ~ mean.NN + Age + (1|LadlabID), family = "binomial", 
#                         data = distinct_model.df)
# anova(model2.endless, base.endless, test = 'LRT')#mean NN significant
```

### Endless: Large model comparison
Put all significant Endless predictors into large model, run model comparison
```{r}
large.endless.base <- glmer(EndlessKnower ~ IHC + Age + (1|LadlabID), 
                            family = "binomial", data = distinct_model.df)

##add highest contig
large.endless.nn <- glmer(EndlessKnower ~ Highest_Contig_NN + IHC + (1|LadlabID), 
                          family = "binomial", data = distinct_model.df)

#compare
anova(large.endless.base, large.endless.nn, test = 'LRT')#Apparently ns?

##add productivity
large.endless.prod <- glmer(EndlessKnower ~ Productivity + IHC + (1|LadlabID), 
                          family = "binomial", data = distinct_model.df)
#convergence warnings, is this an issue?
with(large.endless.prod@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#True, we're okay

#compare 
anova(large.endless.base, large.endless.prod, test = 'LRT')#Productivity is significant

```