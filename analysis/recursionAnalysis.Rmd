---
title: "RecursionAnalysis"
author: "Junyi Chu, Rose M. Schneider, Pierina Cheung"
date: "7/19/2018"
output: 
  html_document:
    toc: yes
    toc_float: yes
---

# Setup
```{r setup, include=FALSE}
rm(list = ls())
require("knitr")
# opts_knit$set(root.dir = "~/Documents/Projects/recursion/") #this is specific to RMS, change accordinglyz
#opts_knit$set(root.dir = "~/Sites/jchu.github.io/recursion/")
opts_knit$set(root.dir = "~/Projects/Junyi study/recursiongithub/") #for PC
library(Hmisc)
library(tidyverse)
library(magrittr)
#library(langcog)
library(lme4)
library(stringr)
library(RColorBrewer)
library(ggthemes)
```

## Loading data
```{r}
#original data
full.data <- read.csv('data/recursion_full.csv', na.strings=c(""," ","NA", "NA "))
```

Reasons for exclusion and their numbers
```{r}
full.data %>%
  dplyr::filter(ExclusionGroup != "include") %>%
  dplyr::distinct(LadlabID, .keep_all = TRUE) %>%
  dplyr::group_by(ExclusionGroup) %>%
  dplyr::summarize(countN = dplyr::n_distinct(LadlabID)) %>%
  kable()
```


RMS original code for checking who failed practice - do not need to run. EVAL set to FALSE
```{r eval = FALSE}

# check how many failed both practice trials
x <- full.data %>%
  filter(Task == "WCN" &
           (TaskItem == 1 | TaskItem == 5))%>%
  group_by(LadlabID)%>%
  summarise(sum = sum(Accuracy))%>%
  filter(sum != 2)

#just hardcoding kids because it's easier than going back to the full data frame
#These kids got 1 right, 5 wrong: 
one.corr <- as.vector(c("012316-BO", "022616-JM", "030216-ED", 
              "030817-ZI", "031516-A", "032216-JH", 
              "032216-RC", "040317-AL", "040317-SL", 
              "041316-AR", "041316-NC", "041316-VN", 
              "062416-MC"))

five.corr <- as.vector("050617-Z1")

zero.corr <- as.vector(c("030216-AD", "040616-K"))


```

Set those who failed the What Comes Next Task practice trials to exclude.
```{r}

#final decision: remove kids who fail 1 trial out of 2 trials, with no additional information about whether E reran the failed trial. Removing 8 kids in total

# pc added 022516-ML on 2018-09-03 as excluded kid based on fail wcn.
# kid's data were NA for practice trials on wcn and 0 correct on test. not sure why prac were marked as NA but assume kid fail wcn.

full.data %<>%
  mutate(ExclusionGroup = ifelse(LadlabID == "022616-JM"| LadlabID == "030216-AD"|
                                   LadlabID == "031516-A" | LadlabID == "041316-AR"|
                                   LadlabID == "041316-VN" | LadlabID == "032216-RC"|
                                   LadlabID == "012316-BO"|LadlabID == "022516-ML", "fail wcn", levels(ExclusionGroup)[ExclusionGroup]),
         ExclusionGroup = as.factor(ExclusionGroup))

# check. good
# full.data %>%
#   filter(LadlabID == "022616-JM")

```

Let's remove anyone who should not be included in the final dataset.
```{r}
full.data %<>%
  dplyr::filter(ExclusionGroup == "include")

```


Now, add in the Productivity classification, IHC, and FHC from PC, JC, and RMS coding

<span style="color:red">Question from RMS: is FHC capped at 100 as well?</span>

```{r}
#productivity, fhc, ihc coding from pc, jc, and rms
hc.data <- read.csv('data/HC-datawide-forcoding - hc.datawide.csv') %>%
  dplyr::select(LadlabID, prod_tomerge, ihc_tomerge, fhc_tomerge, dce)

full.data <- dplyr::left_join(full.data, hc.data, by = "LadlabID")

full.data %<>%
  dplyr::rename(Productivity = prod_tomerge, 
                IHC = ihc_tomerge, 
                FHC = fhc_tomerge, 
                DCE = dce)%>%
  dplyr::mutate(Productivity = factor(Productivity, levels = c("nonprod", "prod"), 
                               labels = c("Nonproductive", "Productive")), 
         IHC = ifelse(IHC > 100, 100, IHC),
         FHC = ifelse(FHC > 100, 100, FHC))
```

Number of kids by age group and average age
```{r}
full.data %>%
  dplyr::group_by(AgeGroup) %>%
  dplyr::summarize(sumAge = n_distinct(LadlabID)) %>%
  kable()

full.data %>%
  dplyr::distinct(LadlabID, .keep_all = TRUE) %>%
  dplyr::summarize(minAge = min(Age),
            maxAge = max(Age),
            meanAge = mean(Age),
            sdAge = sd(Age)) %>%
  kable()

```

Number of kids who were classified as prod, nonprod, NA
```{r}
full.data %>%
  dplyr::distinct(LadlabID, Productivity, Age)%>%
  dplyr::group_by(Productivity)%>%
  dplyr::summarise(n = n(),
                   meanage = mean(Age, na.rm=TRUE),
                   sdage = sd(Age, na.rm=TRUE),
                   minage = min(Age, na.rm=TRUE),
                   maxage = max(Age, na.rm=TRUE)) %>%
  kable()
```

Just for reference, this is the number of kids who switched classifications from PC, JC, RMS recode
```{r}
full.data %>%
  dplyr::filter(TaskType == "productivity") %>%
  droplevels()%>%
  dplyr::distinct(LadlabID, Response, Productivity) %>%
  dplyr::mutate(Response = factor(Response, levels = c("nonprod", "prod"), 
                           labels = c("Nonproductive", "Productive")))%>%
  dplyr::mutate(changed_classification = ifelse((is.na(Response) & Productivity == "Nonproductive"),
                                         "NA_toNonprod",
                                         ifelse((is.na(Response) & Productivity == "Productive"), 
                                                "NA_toProd", 
                                                ifelse((Response == "Nonproductive" & Productivity == "Productive"), 
                                                       "Nonprod_toProd", 
                                                       ifelse((Response == "Productive" & Productivity == "Nonproductive"),
                                                              "Prod_toNonprod", "no_change")))))%>%
  dplyr::group_by(changed_classification)%>%
  dplyr::summarise(n =n())
```

***
# Highest Count Descriptives
Average of IHC, DCE, and FHC for all kids
```{r}
full.data %>%
  dplyr::distinct(LadlabID, IHC)%>%
  dplyr::summarise(mean_IHC = mean(IHC),
            sd_IHC = sd(IHC),
            min_IHC = min(IHC),
            max_IHC = max(IHC),
            median_IHC = median(IHC)) %>%
  kable()

full.data %>%
  dplyr::distinct(LadlabID, DCE)%>%
  dplyr::summarise(mean_DCE = mean(DCE, na.rm=TRUE),
            sd_DCE = sd(DCE, na.rm=TRUE),
            min_DCE = min(DCE, na.rm=TRUE),
            max_DCE = max(DCE, na.rm=TRUE),
            median_DCE = median(DCE, na.rm=TRUE)) %>%
  kable()

full.data %>%
  dplyr::distinct(LadlabID, FHC)%>%
  dplyr::summarise(mean_FHC = mean(FHC),
            sd_FHC = sd(FHC),
            min_FHC = min(FHC),
            max_FHC = max(FHC),
            median_FHC = median(FHC)) %>%
  kable()
```

Similar data by productivity
```{r}
full.data %>%
  dplyr::distinct(LadlabID, Productivity, IHC)%>%
  dplyr::group_by(Productivity)%>%
  dplyr::summarise(mean_IHC = mean(IHC),
            sd_IHC = sd(IHC),
            min_IHC = min(IHC),
            max_IHC = max(IHC),
            median_IHC = median(IHC)) %>%
  kable()

full.data %>%
  dplyr::distinct(LadlabID, Productivity, DCE)%>%
  dplyr::group_by(Productivity)%>%
  dplyr::summarise(mean_DCE = mean(DCE, na.rm=TRUE),
            sd_DCE = sd(DCE, na.rm=TRUE),
            min_DCE = min(DCE, na.rm=TRUE),
            max_DCE = max(DCE, na.rm=TRUE),
            median_DCE = median(DCE, na.rm=TRUE)) %>%
  kable()

full.data %>%
  dplyr::distinct(LadlabID, Productivity, FHC)%>%
  dplyr::group_by(Productivity)%>%
  dplyr::summarise(mean_FHC = mean(FHC),
            sd_FHC = sd(FHC),
            min_FHC = min(FHC),
            max_FHC = max(FHC),
            median_FHC = median(FHC)) %>%
  kable()
```






Plotting distribution of IHC, as a function of productivity (~ junyi's graph)

```{r}
unique.hc.data <- full.data %>%
  dplyr::distinct(LadlabID, Gender, Age, AgeGroup, HCReceivedSupport, IHC, DCE, FHC, Productivity)

ggplot(unique.hc.data, aes(x=IHC, color=Productivity)) + 
  geom_dotplot(aes(fill = Productivity),
    binwidth=1, stackgroups=TRUE, binpositions="all",method="dotdensity") +
  scale_color_brewer(palette="Set2") + 
  scale_fill_brewer(palette="Set2") +
  coord_fixed(ratio=1) +
  scale_y_continuous(breaks=seq(0,40,10), lim=c(0,35)) +
  scale_x_continuous(breaks=seq(0,100,by=10)) +
  labs(title="Initial Highest Count",  
       x="IHC (no error)", 
       y="Frequency") +
  theme_bw() + 
  theme(legend.position="bottom")
ggsave('graphs/ihc-by-prod.png')
# hist(unique.hc.data$IHC)
```

Plotting productivity as a function of age in months

```{r}
unique.hc.data$AgeMonths = floor(unique.hc.data$Age*12)

ggplot(unique.hc.data, aes(x=AgeMonths, colour = Productivity)) + 
  geom_dotplot(aes(fill = Productivity),
               binwidth = 1,
               stackgroups=TRUE, binpositions="all") +
  coord_fixed(ratio=1) +
  scale_y_continuous(breaks=seq(0,10,5), lim=c(0,12)) +
  scale_x_continuous(breaks=seq(48,72,by=6)) +
  scale_color_brewer(palette="Set2") + 
  scale_fill_brewer(palette="Set2") +
  labs(title="Productivity by Age", 
       x="Age in Months", 
       y="Frequency") +
  theme_bw() + 
  theme(legend.position="bottom")
ggsave('graphs/prod-by-age.png')

```

Distance between IHC and FHC

Restruture data to plot distance between ihc, dce, and final count
```{r}
hc.dev.data <- full.data %>%
  dplyr::select(LadlabID, Age, Productivity, IHC, DCE, FHC) %>%
  gather(hcprogression, hc, IHC:FHC)%>%
  mutate(hcprogression = factor(hcprogression, levels = c("IHC", "DCE", "FHC")))

#all kids together
ggplot(hc.dev.data, aes(x = LadlabID, y = hc)) + 
  facet_grid(rows = vars(Productivity)) +
  geom_line(data=hc.dev.data[!is.na(hc.dev.data$hc),]) + 
  geom_point(aes(shape = hcprogression, colour = hcprogression), 
             size = 2, stroke = 1.5) +
  scale_color_brewer(palette="Dark2") +
  scale_shape_manual(values = c(4,5,20)) +
  labs(title="Highest Count Progression by Decade Productivity",
       x = "Each line = individual kids",
       y="Highest Count by Count Type") +
  theme_bw() + 
  theme(legend.position="bottom", 
        axis.text.x = element_text(angle = 270, hjust = 1)) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

hc.dev.prod <- subset(hc.dev.data, Productivity == "Productive")
hc.dev.nonprod <- subset(hc.dev.data, Productivity == "Nonproductive")

#for easier viewing, just going to break this up into individual plots
#productive
ggplot(hc.dev.prod, aes(x = LadlabID, y = hc)) + 
  facet_grid(rows = vars(Productivity)) +
  geom_line(data=hc.dev.prod[!is.na(hc.dev.prod$hc),]) + 
  geom_point(aes(shape = hcprogression, colour = hcprogression), 
             size = 2, stroke = 1.5) +
  scale_color_brewer(palette="Dark2") +
  scale_shape_manual(values = c(4,5,20)) +
  ylim(0, 100) +
  labs(title="Distance, productive",
       x = "Each line = individual kids",
       y="Highest Count by Count Type") +
  theme_bw() + 
  theme(legend.position="bottom", 
        axis.text.x = element_text(angle = 270, hjust = 1)) + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
ggsave('graphs/distance-prod.png')

#nonproductive
ggplot(hc.dev.nonprod, aes(x = LadlabID, y = hc)) + 
  facet_grid(rows = vars(Productivity)) +
  geom_line(data=hc.dev.nonprod[!is.na(hc.dev.nonprod$hc),]) + 
  geom_point(aes(shape = hcprogression, colour = hcprogression), 
             size = 2, stroke = 1.5) +
  scale_color_brewer(palette="Dark2") +
  scale_shape_manual(values = c(4,5,20)) +
  ylim(0, 100) +
  labs(title="Distance, Nonproductive",
       x = "Each line = individual kids",
       y="Highest Count by Count Type") +
  theme_bw() + 
  theme(legend.position="bottom", 
        axis.text.x = element_text(angle = 270, hjust = 1)) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
ggsave('graphs/distance-nonprod.png')

```

Number of kids who counted to 99+ spontaneously on IHC plus those whose FHC = 99+ without prompting
```{r}
# full.data %>%
#   filter(IHC > 98) %>%
#   distinct(LadlabID, IHC, FHC, HCReceivedSupport) %>%
#   count() #n=32
# but some kids made errors past IHC but < 3 so need to account for that

full.data %>%
  filter(FHC > 98 & (is.na(HCReceivedSupport)|HCReceivedSupport != 1)) %>%
  distinct(LadlabID, IHC, FHC, HCReceivedSupport) %>%
  count() #n =42

```

Average number of decade prompts provided. Productive counters first
```{r}
full.data %>%
  filter(TaskItem == "times") %>%
  filter(Productivity == "Productive") %>%
  distinct(LadlabID, HCReceivedSupport, TaskItem, Response) %>%
  mutate(Response = as.numeric(levels(Response)[Response])) %>%
  group_by(HCReceivedSupport) %>%
  summarize(mean = mean(Response, na.rm=TRUE),
            sd = sd(Response, na.rm=TRUE),
            min = min(Response, na.rm=TRUE),
            max = max(Response, na.rm=TRUE),
            count=n())
# assume 0 = NA
# error in supported.times coding, should only count to 90
# but one kid got prompted with 100 and 110 and times should be 0

```


Then nonproductive counters.
```{r}
full.data %>%
  filter(TaskItem == "times") %>%
  filter(Productivity == "Nonproductive") %>%
  distinct(LadlabID, HCReceivedSupport, TaskItem, Response) %>%
  mutate(Response = as.numeric(levels(Response)[Response])) %>%
  group_by(HCReceivedSupport) %>%
  summarize(mean = mean(Response, na.rm=TRUE),
            sd = sd(Response, na.rm=TRUE),
            min = min(Response, na.rm=TRUE),
            max = max(Response, na.rm=TRUE),
            count=n())
# assume 0 = NA
# error in supported.times coding, should only count to 90
# but one kid got prompted with 100 and 110 and times should be 0
```




# What Comes Next Descriptives

<span style="color:red">Note practice trials 1 and 5 are included in highest contig NN computation but not in overall percent correct, or within vs. beyond - PC</span>

First check if Accuracy column in full.data is coded correctly. Good to go.
```{r}
wcn.data <- full.data %>%
   filter(Task == "WCN")

wcn.data %<>%
  mutate(Response_num = as.numeric(as.character(Response)), 
         TaskItem_num = as.numeric(as.character(TaskItem)), 
         Accuracy_check = ifelse(Response_num == (TaskItem_num + 1), 1, 0), 
         Accuracy_valid = ifelse(Accuracy == Accuracy_check, TRUE, FALSE))

validate <- function(){
  validation <- wcn.data %>%
  filter(Accuracy_valid == FALSE)
  if(length(validation$LadlabID) > 0) {
    print("WARNING: CHECK CODING")
  } else {
    print("All coding correct")
  }
}

validate()
```


```{r}
# PC ask: do we need this?

# wcn.test <- wcn.data %>%
#  mutate(Response_num = as.numeric(as.character(Response)), 
#         TaskItem_num = as.numeric(as.character(TaskItem)), 
#         Response_check = ifelse(Response == Response_num, TRUE, FALSE), 
#         TaskItem_check = ifelse(TaskItem == TaskItem_num, TRUE, FALSE))%>%
#  filter(Response_check == FALSE | TaskItem_check == FALSE)
```

WCN: Children were provided with momentum trials if they got wrong on immediate trials. Check %trials where immediate = wrong, momentum = right
```{r}
wcn.wide <- full.data %>%
  filter(ExclusionGroup == "include") %>%
  filter(Task == "WCN") %>%
  filter(TaskType != "practice") %>%
  filter(TaskItem != 3) %>% # a trial on 3 for momentum that doesn't exist for immediate
  droplevels()%>%
  dplyr::select(LadlabID, Age, AgeGroup, TaskType, TaskItem, Accuracy, Productivity) %>%
  spread(TaskType, Accuracy)

# data check: there shouldn't be any kids who got 1 for immediate but 0 for momentum or 1 for immediate and 1 for momentum (less of a problem)
##pulling out these kids below
wcn.check <- full.data %>%
  filter(Task == "WCN", 
         TaskType == "momentum" | TaskType == "immediate")%>%
  dplyr::select(LadlabID, Age, AgeGroup, TaskType, TaskItem, Accuracy) %>%
  spread(TaskType, Accuracy)%>%
  mutate(issue_immediate1Momentum0 = ifelse(immediate == 1 & momentum == 0, TRUE, FALSE), 
         issue_immediate1Momentum1 = ifelse(immediate == 1 & momentum == 1, TRUE, FALSE))%>%
  filter(issue_immediate1Momentum0 == TRUE | 
           issue_immediate1Momentum1 == TRUE)
#7 kids with this issue - exclude??
#PC: I think we can keep them but we should check the coding sheet. Can keep because presumaly they shouldn't be tested on momentum if they got immeidate right.

# how many kids show improved performance
xtabs(~immediate + momentum, data = wcn.wide, na.action = na.pass, exclude = NULL)
# 191 / 1048 trials = ~ 18%. NOTE % not by kids but by trials.
```

Percent Correct on WCN
```{r}
wcn.wide %>%
  dplyr::group_by(LadlabID) %>%
  dplyr::summarize(avg.wcn = mean(immediate, na.rm=TRUE),
            sd.wcn = sd(immediate, na.rm=TRUE)) %>%
  dplyr::summarize(avg = mean(avg.wcn),
            sd = sd(sd.wcn))

wcn.wide %>%
  dplyr::group_by(LadlabID, Productivity) %>%
  dplyr::summarize(avg.wcn = mean(immediate, na.rm=TRUE),
            sd.wcn = sd(immediate, na.rm=TRUE)) %>%
  dplyr::group_by(Productivity) %>%
  dplyr::summarize(avg = mean(avg.wcn),
            sd = sd(sd.wcn))
```

Plotting %corr on WCN as function of productivity
```{r}
wcn.wide %>%
  dplyr::group_by(LadlabID, Productivity) %>%
  dplyr::summarize(avg.wcn = mean(immediate, na.rm=TRUE),
            sd.wcn = sd(immediate, na.rm=TRUE)) %>%
  ggplot(aes(x = Productivity, y = avg.wcn, fill=factor(Productivity))) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .5, colour = "black") +
  stat_summary(fun.data = mean_se, geom="errorbar", 
               position = position_dodge(width=0.90), width = 0.2)+
  scale_fill_discrete(name = "Decade Productivity") +
  ylab("Proportion Correct") + 
  xlab('') + 
  theme_bw() + 
  theme(legend.position = "none") +
  ggtitle("Overall proportion correct on the What Comes Next Task") +
  theme(text = element_text(size = 12)) +
  ylim(0, 1.0) +
  geom_violin(alpha = .1)
ggsave('graphs/wcn-percentcorr.png')

```
     
Add whether the Task Item was within or outside of the kid's initial highest count.
```{r}
#first, get initial highest count for each kiddo
#Make a lookup table with SID and initial highest count
lookup <- full.data %>%
  distinct(LadlabID, IHC)

wcn.wide %<>%
  dplyr::mutate(TaskItem = as.numeric(as.character(TaskItem)))

#This is a function that, for each trial, checks the number queried. If number queried is above the child's initial highest count, marks that trial as beyond count range.
determine_count_range <- function(df) {
  tmp <- df
  for (row in 1:nrow(tmp)) {
    sub = as.character(tmp[row, "LadlabID"])
    count_range = as.numeric(as.character(subset(lookup, LadlabID == sub)$IHC))
    tmp[row, "IHC"] = as.numeric(as.character(count_range))
    if (tmp[row, "TaskItem"] > count_range) {
      tmp[row, "WithinOutsideIHC"] = "outside"
    } else {
      tmp[row, "WithinOutsideIHC"] = "within"
    }
  }
  return(tmp)
}

#Run for wcn
wcn.wide <- determine_count_range(wcn.wide)
```

WCN accuracy, within and outside of IHC
```{r}
wcn.wide %>%
  dplyr::group_by(WithinOutsideIHC) %>%
  dplyr::summarize(mean = mean(immediate, na.rm = TRUE), 
            sd = sd(immediate, na.rm = TRUE))
```
     

Now WCN by within/outside count range and productivity
```{r}
wcn.wide %>%
  dplyr::group_by(Productivity, WithinOutsideIHC) %>%
  dplyr::summarize(mean = mean(immediate, na.rm = TRUE), 
            sd = sd(immediate, na.rm = TRUE))
```

Plotting WCN as within vs. beyond by productivity 
```{r}
wcn.wide %>%
  dplyr::group_by(Productivity, WithinOutsideIHC, LadlabID) %>%
  dplyr::summarize(meansubj = mean(immediate, na.rm = TRUE)) %>%
  ggplot(aes(x=Productivity, y=meansubj, fill=WithinOutsideIHC)) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .5, colour = "black") +
  stat_summary(fun.data = mean_se, geom="errorbar",
               position = position_dodge(width=0.90), width = 0.2) +
  scale_fill_discrete(name = "Within vs. Beyond IHC") +
  scale_y_continuous(lim=c(0,1)) +
  labs(title="Within vs. Beyond WCN by Productivity", 
       y="Proportion Correct", 
       fill="Item type") +
  theme_bw() +
  theme(text = element_text(size = 12))
ggsave('graphs/wcn-within-beyond.png')

```

How many trials do kids have beyond their IHC?
```{r}
wcn.wide %>%
  dplyr:: select(-momentum)%>%
  dplyr::group_by(Productivity, WithinOutsideIHC)%>%
  dplyr::summarise(n = n())
```

Highest contiguous NN

```{r}

unique.nn <- as.vector(unique(wcn.wide$LadlabID))
#get the task items from wcn
nextnums <- as.vector(unique(wcn.wide$TaskItem))

#this is a function that pulls out the largest number for which a participant had a correct consecutive
get_contiguous <- function(){
  contig <- data.frame()
  for (sub in unique.nn) {
    tmp <- wcn.wide %>%
      dplyr::select(LadlabID, Age, AgeGroup, TaskItem, immediate)%>%
      filter(LadlabID == sub, 
             immediate == 0)%>%
      mutate(TaskItem = sort(TaskItem))
    if (length(tmp$LadlabID) == 0) {
      highest_contig = 86
      sub_contig <- data.frame(sub, highest_contig)
      contig <- bind_rows(contig, sub_contig)
    } else if (length(tmp$TaskItem) > 0 & min(tmp$TaskItem) == 23) {
      #if(sub %in% one.corr){
        highest_contig = 5
        sub_contig <- data.frame(sub, highest_contig)
        contig <- bind_rows(contig, sub_contig)
      # } else if(sub %in% five.corr | sub %in% zero.corr){
      #   highest_contig = 0
      #   sub_contig <- data.frame(sub, highest_contig)
      #   contig <- bind_rows(contig, sub_contig)
      # } else {
      #   highest_contig = 5
      #   sub_contig <- data.frame(sub, highest_contig)
      #   contig <- bind_rows(contig, sub_contig)
      # }
    } else {
      min.nn <- min(tmp$TaskItem)
      prev_correct <- nextnums[nextnums < min.nn]
      highest_contig <- max(prev_correct)
    
      sub_contig <- data.frame(sub,
                             highest_contig)
      contig <- bind_rows(contig, sub_contig)
    }
  }
  return(contig)
}

highest_contiguous_nn <- get_contiguous()%>%
  dplyr::rename(LadlabID = sub)%>%
  distinct(LadlabID, highest_contig)%>%
  rename(Highest_Contig_NN = highest_contig)

```

Code for checking highest contig NN
```{r}
full.data %>%
  filter(LadlabID == "022316-AB") %>%
  filter(TaskType == "immediate"|TaskType == "practice") %>%
  select(LadlabID, TaskType, TaskItem, Accuracy)

# these two kids, for example, had the same contig highest NN but diff profile of responses
#040317-KK #7 correct out of 10
#022316-AB #9 correct out of 10


# wcn.data %<>%
#   dplyr::right_join(highest_contiguous_nn) 
# 
# wcn.data %>%
#   filter(LadlabID == "040317-KK")
  
```

```{r}
wcn.data %>%
  dplyr::right_join(highest_contiguous_nn) %>%
  dplyr::filter(TaskType == "immediate"|TaskType == "practice") %>% #added prac for 1&5
  dplyr::group_by(LadlabID, Highest_Contig_NN) %>%
  dplyr::summarize(n_corr = sum(Accuracy)) %>%
  dplyr::group_by(Highest_Contig_NN, n_corr, na.rm=TRUE) %>%
  dplyr::summarize(n_participants = n_distinct(LadlabID)) %>%
  tidyr::spread(n_corr, n_participants) %>%
  kable()


# 2 kids had NA as n_corr

wcn.data %>%
  dplyr::right_join(highest_contiguous_nn) %>%
  dplyr::filter(TaskType == "immediate"|TaskType == "practice") %>% #added prac for 1&5
  dplyr::group_by(LadlabID, Highest_Contig_NN) %>%
  dplyr::summarize(n_corr = sum(Accuracy)) %>%
  dplyr::group_by(Highest_Contig_NN, n_corr) %>%
  filter(is.na(n_corr))
# 022516-ML
# 040317-SL

# this kid got 0 for all test and NA for 1 and 5. Not one of the two kids under zero.corr
# I know why: only kids with sum < 2 were pulled out. this kid's sum is NA
full.data %>%
  filter(LadlabID == "022516-ML") %>%
  filter(TaskType == "immediate"|TaskType == "practice") %>%
  select(LadlabID, TaskType, TaskItem, Accuracy)

# this kid has one NA value but otherwise look fine
# now added na.rm=TRUE for sum(accuracy)
full.data %>%
  filter(LadlabID == "040317-SL") %>%
  filter(TaskType == "immediate"|TaskType == "practice") %>%
  select(LadlabID, TaskType, TaskItem, Accuracy)


```

Median highest contiguous next number by productivity 
```{r}
full.data %>%
  dplyr::right_join(highest_contiguous_nn) %>%
  dplyr::distinct(LadlabID, Highest_Contig_NN, Productivity) %>%
  dplyr::group_by(Productivity) %>%
  dplyr::summarise(median = median(Highest_Contig_NN)) %>%
  kable()

```

Plotting freq of highest contiguous as a function of productivity
``` {r}
full.data %>%
  dplyr::right_join(highest_contiguous_nn) %>%
  dplyr::distinct(LadlabID, Highest_Contig_NN, Productivity) %>%
  ggplot(aes(x=Highest_Contig_NN, color=Productivity)) + 
  geom_dotplot(aes(fill = Productivity),
    binwidth=1, stackgroups=TRUE, binpositions="all",method="dotdensity") +
  scale_color_brewer(palette="Set2") + 
  scale_fill_brewer(palette="Set2") +
  coord_fixed(ratio=1) +
  scale_y_continuous(breaks=seq(0,50,10), lim=c(0,50)) +
  #scale_x_continuous(breaks=seq(0,100,by=10)) +
  scale_x_continuous(breaks = c(0, 1, 5, 23, 29, 37, 40, 62, 70, 86),
                     labels=c("0", "1", "5", "23", "29", "37", "40", "62", "70", "86")) +
  labs(title="Highest Contiguous Next Number by Decade Productivity",  
       x="Highest Contiguous Next Number", 
       y="Frequency") +
  theme_bw() + 
  theme(legend.position="bottom")
ggsave('graphs/highestcontig-by-prod.png')

```


Correlations
```{r}
corrdf <- full.data %>%
  dplyr::right_join(highest_contiguous_nn) %>%
  dplyr::distinct(LadlabID, Highest_Contig_NN, Age, IHC, FHC) %>%
  dplyr::select(-LadlabID)

rcorr(as.matrix(corrdf), type = "pearson")
```

# Infinity Descriptives
```{r}
full.data %>%
  dplyr::distinct(LadlabID, Category)%>%
  dplyr::group_by(Category)%>%
  dplyr::summarise(n = n())

full.data %>%
  dplyr::distinct(LadlabID, SuccessorKnower, Productivity)%>%
  dplyr::group_by(SuccessorKnower, Productivity)%>%
  dplyr::summarise(n = n()) %>%
  spread(Productivity, n)

full.data %>%
  dplyr::distinct(LadlabID, EndlessKnower, Productivity)%>%
  dplyr::group_by(EndlessKnower, Productivity)%>%
  dplyr::summarise(n = n()) %>%
  spread(Productivity, n)

```



# Analyses
## 1: Counting, Productivity, and Infinity Battery
To identify whether there is connection between counting experience and Infinity Task performance, we will conduct three initial analyses, predicting Infinity Task performance from either (1) Initial Highest Count, (2) Productivity for Decade Rule (defined above), or (3) performance on the Next Number task. 

glmer(inf.0/1 ~ (predictor) + age + (1|subject), family = binomial).

---
First, we need to make a model data frame that readily has all of this information

```{r}
#model base
model.df <- full.data %>%
  dplyr::select(LadlabID, Age, AgeGroup, Gender, Task, Response, SuccessorKnower, EndlessKnower, 
                IHC, FHC, DCE, Productivity)
```

Highest Next Number - commented because we're using highest contiguous
```{r}
# lookup <- full.data %>%
#   filter(Task == "WCN", 
#          Accuracy == 1)%>%
#   group_by(LadlabID)%>%
#   summarise(max = max(as.numeric(as.character(TaskItem)))) 
# 
# 
# #Add highest NN to model df
# add_highest_num <- function() {
#   tmp <- model.df
#   for (row in 1:nrow(tmp)) {
#     sub = as.character(tmp[row, "LadlabID"])
#     highest_num = subset(lookup, LadlabID == sub)$max
#     tmp[row, "Highest_NN"] = highest_num
#   }
#   return(tmp)
# }
# 
# #run this function on model df
# model.df <- add_highest_num()
```

Add highest contiguous next number to model.df 
```{r}
model.df <- right_join(model.df, highest_contiguous_nn, by = "LadlabID")

# hc.datawide <- right_join(hc.datawide, highest_contiguous_nn, by = "LadlabID")

# hc.datawide %>%
#   dplyr::select(LadlabID, Age, AgeGroup, productivity, max, 
#     HCReceivedSupport, ihc, dce, sup.noerror) %>%
#   group_by(productivity) %>%
#   summarize(median = median(max, na.rm=TRUE),
#             count = n())
# #median is 86 for all groups
```

Get mean WCN for everyone <span style="color:red">Not using this anymore - RMS</span>
```{r}
# lookup <- wcn.wide %>%
#   group_by(LadlabID)%>%
#   summarise(mean.NN = mean(immediate, na.rm = TRUE))
```

## Successor models
```{r}
#each participant only needs one row here, because we only need to know whether they are a Successor Knower or Endless Knower
distinct_model.df <- model.df %>%
  distinct(LadlabID, Age, AgeGroup, Gender, SuccessorKnower, EndlessKnower, 
           IHC, Highest_Contig_NN, FHC, DCE, Productivity)%>%
  mutate(SuccessorKnower = factor(SuccessorKnower, levels = c(0,1)), 
         EndlessKnower = factor(EndlessKnower, levels = c(0,1)))%>%
  mutate(IHC = as.integer(IHC), 
         Highest_Contig_NN = as.integer(Highest_Contig_NN), 
         LadlabID = factor(LadlabID))

# #add mean_nn to model df
# distinct_model.df <- right_join(distinct_model.df, lookup, by = "LadlabID")

###MODEL BUILDING AND COMPARISONS###
#base model for successor knower
base.successor <- glmer(SuccessorKnower ~ Age + (1|LadlabID), family = "binomial", 
                    data = distinct_model.df)

##IHC model##
model.ihc.successor <- glmer(SuccessorKnower ~ IHC + Age + (1|LadlabID), family = "binomial", 
                   data = distinct_model.df)
#convergence warnings, is this an issue?
with(model.ihc.successor@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#True, so we're okay

#compare
anova(base.successor, model.ihc.successor, test = 'LRT') #IHC not significant

##Highest NN Model##
model.nn.successor <- glmer(SuccessorKnower ~ Highest_Contig_NN + Age + (1|LadlabID), family = "binomial", 
                   data = distinct_model.df)

#compare
anova(base.successor, model.nn.successor, test = 'LRT')#highest contiguous NN not significant

##Productivity model##
model.prod.successor <- glmer(SuccessorKnower ~ Productivity + Age + (1|LadlabID), family = "binomial",
                   data = distinct_model.df)

#compare
anova(base.successor, model.prod.successor, test = 'LRT')#Productivity trending
```


## Endless Models
```{r}
base.endless <- glmer(EndlessKnower ~ Age + (1|LadlabID), family = "binomial", 
                      data = distinct_model.df)

###IHC MODEL###
model.ihc.endless <- glmer(EndlessKnower ~ IHC + Age + (1|LadlabID), family = "binomial", 
                        data = distinct_model.df)
#convergence warnings, is this an issue?
with(model.ihc.endless@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#true, so we're okay

#compare
anova(base.endless, model.ihc.endless, test = 'LRT') #IHC significant


###HIGHEST CONTIG NN MODEL###
model.nn.endless <- glmer(EndlessKnower ~ Highest_Contig_NN + Age + (1|LadlabID), family = "binomial", 
                        data = distinct_model.df) 
#convergence warnings, is this an issue?
with(model.nn.endless@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#True, model converging

anova(model.nn.endless, base.endless, test = 'LRT')#Highest contig NN significant

###PRODUCTIVITY MODEL###
model.prod.endless <- glmer(EndlessKnower ~ Productivity + Age + (1|LadlabID), family = "binomial", 
                            data = distinct_model.df)

#compare
anova(model.prod.endless, base.endless, test = 'LRT')#Prod significant

# #okay with about mean NN
# model2.endless <- glmer(EndlessKnower ~ mean.NN + Age + (1|LadlabID), family = "binomial", 
#                         data = distinct_model.df)
# anova(model2.endless, base.endless, test = 'LRT')#mean NN significant
```

### Endless: Large model comparison
Put all significant Endless predictors into large model, run model comparison

```{r}
large.endless.base <- glmer(EndlessKnower ~ IHC + Age + (1|LadlabID), 
                            family = "binomial", data = distinct_model.df)
#convergence warnings, is this an issue?
with(large.endless.base@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#True, we're okay

##add highest contig
large.endless.nn <- glmer(EndlessKnower ~ Highest_Contig_NN + IHC + (1|LadlabID), 
                          family = "binomial", data = distinct_model.df)

#compare
anova(large.endless.base, large.endless.nn, test = 'LRT')#Apparently ns?

##add productivity
large.endless.prod <- glmer(EndlessKnower ~ Productivity + Highest_Contig_NN + IHC + (1|LadlabID), 
                          family = "binomial", data = distinct_model.df)
#convergence warnings, is this an issue?
with(large.endless.prod@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#True, we're okay

#compare 
anova(large.endless.base, large.endless.prod, test = 'LRT')#Productivity is significant

# productivity not sig. 
# Old code didn't add highest_contig_nn to model. only had prod & ihc. doesn't seem right? (PC)

```


#### Pierina exploring using overall %corr as predictor
```{r}
###MODEL BUILDING AND COMPARISONS###
#base model for successor knower
base.successor <- glmer(SuccessorKnower ~ Age + (1|LadlabID), family = "binomial", 
                    data = distinct_model.df)

##IHC model##
model.ihc.successor <- glmer(SuccessorKnower ~ IHC + Age + (1|LadlabID), family = "binomial", 
                   data = distinct_model.df)
#convergence warnings, is this an issue?
with(model.ihc.successor@optinfo$derivs,max(abs(solve(Hessian,gradient)))<2e-3)#True, so we're okay

#compare
anova(base.successor, model.ihc.successor, test = 'LRT') #IHC not significant

##Highest NN Model##
model.nn.successor <- glmer(SuccessorKnower ~ Highest_Contig_NN + Age + (1|LadlabID), family = "binomial", 
                   data = distinct_model.df)

#compare
anova(base.successor, model.nn.successor, test = 'LRT')#highest contiguous NN not significant

##Productivity model##
model.prod.successor <- glmer(SuccessorKnower ~ Productivity + Age + (1|LadlabID), family = "binomial",
                   data = distinct_model.df)

#compare
anova(base.successor, model.prod.successor, test = 'LRT')#Productivity trending
```